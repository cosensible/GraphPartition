// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GraphPartition.proto

#ifndef PROTOBUF_INCLUDED_GraphPartition_2eproto
#define PROTOBUF_INCLUDED_GraphPartition_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_GraphPartition_2eproto 

namespace protobuf_GraphPartition_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_GraphPartition_2eproto
namespace pb {
class GraphPartition;
class GraphPartitionDefaultTypeInternal;
extern GraphPartitionDefaultTypeInternal _GraphPartition_default_instance_;
class GraphPartition_Edge;
class GraphPartition_EdgeDefaultTypeInternal;
extern GraphPartition_EdgeDefaultTypeInternal _GraphPartition_Edge_default_instance_;
class GraphPartition_Input;
class GraphPartition_InputDefaultTypeInternal;
extern GraphPartition_InputDefaultTypeInternal _GraphPartition_Input_default_instance_;
class GraphPartition_Node;
class GraphPartition_NodeDefaultTypeInternal;
extern GraphPartition_NodeDefaultTypeInternal _GraphPartition_Node_default_instance_;
class GraphPartition_Output;
class GraphPartition_OutputDefaultTypeInternal;
extern GraphPartition_OutputDefaultTypeInternal _GraphPartition_Output_default_instance_;
class Submission;
class SubmissionDefaultTypeInternal;
extern SubmissionDefaultTypeInternal _Submission_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::GraphPartition* Arena::CreateMaybeMessage<::pb::GraphPartition>(Arena*);
template<> ::pb::GraphPartition_Edge* Arena::CreateMaybeMessage<::pb::GraphPartition_Edge>(Arena*);
template<> ::pb::GraphPartition_Input* Arena::CreateMaybeMessage<::pb::GraphPartition_Input>(Arena*);
template<> ::pb::GraphPartition_Node* Arena::CreateMaybeMessage<::pb::GraphPartition_Node>(Arena*);
template<> ::pb::GraphPartition_Output* Arena::CreateMaybeMessage<::pb::GraphPartition_Output>(Arena*);
template<> ::pb::Submission* Arena::CreateMaybeMessage<::pb::Submission>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

// ===================================================================

class GraphPartition_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GraphPartition.Input) */ {
 public:
  GraphPartition_Input();
  virtual ~GraphPartition_Input();

  GraphPartition_Input(const GraphPartition_Input& from);

  inline GraphPartition_Input& operator=(const GraphPartition_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPartition_Input(GraphPartition_Input&& from) noexcept
    : GraphPartition_Input() {
    *this = ::std::move(from);
  }

  inline GraphPartition_Input& operator=(GraphPartition_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPartition_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPartition_Input* internal_default_instance() {
    return reinterpret_cast<const GraphPartition_Input*>(
               &_GraphPartition_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GraphPartition_Input* other);
  friend void swap(GraphPartition_Input& a, GraphPartition_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition_Input* New() const final {
    return CreateMaybeMessage<GraphPartition_Input>(NULL);
  }

  GraphPartition_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPartition_Input& from);
  void MergeFrom(const GraphPartition_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.GraphPartition.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::pb::GraphPartition_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Node >*
      mutable_nodes();
  const ::pb::GraphPartition_Node& nodes(int index) const;
  ::pb::GraphPartition_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Node >&
      nodes() const;

  // repeated .pb.GraphPartition.Edge edges = 2;
  int edges_size() const;
  void clear_edges();
  static const int kEdgesFieldNumber = 2;
  ::pb::GraphPartition_Edge* mutable_edges(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Edge >*
      mutable_edges();
  const ::pb::GraphPartition_Edge& edges(int index) const;
  ::pb::GraphPartition_Edge* add_edges();
  const ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Edge >&
      edges() const;

  // @@protoc_insertion_point(class_scope:pb.GraphPartition.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Edge > edges_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPartition_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GraphPartition.Output) */ {
 public:
  GraphPartition_Output();
  virtual ~GraphPartition_Output();

  GraphPartition_Output(const GraphPartition_Output& from);

  inline GraphPartition_Output& operator=(const GraphPartition_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPartition_Output(GraphPartition_Output&& from) noexcept
    : GraphPartition_Output() {
    *this = ::std::move(from);
  }

  inline GraphPartition_Output& operator=(GraphPartition_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPartition_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPartition_Output* internal_default_instance() {
    return reinterpret_cast<const GraphPartition_Output*>(
               &_GraphPartition_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GraphPartition_Output* other);
  friend void swap(GraphPartition_Output& a, GraphPartition_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition_Output* New() const final {
    return CreateMaybeMessage<GraphPartition_Output>(NULL);
  }

  GraphPartition_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPartition_Output& from);
  void MergeFrom(const GraphPartition_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 nodepart = 1;
  int nodepart_size() const;
  void clear_nodepart();
  static const int kNodepartFieldNumber = 1;
  ::google::protobuf::int32 nodepart(int index) const;
  void set_nodepart(int index, ::google::protobuf::int32 value);
  void add_nodepart(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      nodepart() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_nodepart();

  // @@protoc_insertion_point(class_scope:pb.GraphPartition.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > nodepart_;
  mutable int _nodepart_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPartition_Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GraphPartition.Node) */ {
 public:
  GraphPartition_Node();
  virtual ~GraphPartition_Node();

  GraphPartition_Node(const GraphPartition_Node& from);

  inline GraphPartition_Node& operator=(const GraphPartition_Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPartition_Node(GraphPartition_Node&& from) noexcept
    : GraphPartition_Node() {
    *this = ::std::move(from);
  }

  inline GraphPartition_Node& operator=(GraphPartition_Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPartition_Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPartition_Node* internal_default_instance() {
    return reinterpret_cast<const GraphPartition_Node*>(
               &_GraphPartition_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GraphPartition_Node* other);
  friend void swap(GraphPartition_Node& a, GraphPartition_Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition_Node* New() const final {
    return CreateMaybeMessage<GraphPartition_Node>(NULL);
  }

  GraphPartition_Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition_Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPartition_Node& from);
  void MergeFrom(const GraphPartition_Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 wgt = 1;
  void clear_wgt();
  static const int kWgtFieldNumber = 1;
  ::google::protobuf::int32 wgt() const;
  void set_wgt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.GraphPartition.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 wgt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPartition_Edge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GraphPartition.Edge) */ {
 public:
  GraphPartition_Edge();
  virtual ~GraphPartition_Edge();

  GraphPartition_Edge(const GraphPartition_Edge& from);

  inline GraphPartition_Edge& operator=(const GraphPartition_Edge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPartition_Edge(GraphPartition_Edge&& from) noexcept
    : GraphPartition_Edge() {
    *this = ::std::move(from);
  }

  inline GraphPartition_Edge& operator=(GraphPartition_Edge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPartition_Edge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPartition_Edge* internal_default_instance() {
    return reinterpret_cast<const GraphPartition_Edge*>(
               &_GraphPartition_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GraphPartition_Edge* other);
  friend void swap(GraphPartition_Edge& a, GraphPartition_Edge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition_Edge* New() const final {
    return CreateMaybeMessage<GraphPartition_Edge>(NULL);
  }

  GraphPartition_Edge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition_Edge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPartition_Edge& from);
  void MergeFrom(const GraphPartition_Edge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition_Edge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 beg = 1;
  void clear_beg();
  static const int kBegFieldNumber = 1;
  ::google::protobuf::int32 beg() const;
  void set_beg(::google::protobuf::int32 value);

  // int32 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // int32 wgt = 3;
  void clear_wgt();
  static const int kWgtFieldNumber = 3;
  ::google::protobuf::int32 wgt() const;
  void set_wgt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.GraphPartition.Edge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 beg_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 wgt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraphPartition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GraphPartition) */ {
 public:
  GraphPartition();
  virtual ~GraphPartition();

  GraphPartition(const GraphPartition& from);

  inline GraphPartition& operator=(const GraphPartition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphPartition(GraphPartition&& from) noexcept
    : GraphPartition() {
    *this = ::std::move(from);
  }

  inline GraphPartition& operator=(GraphPartition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraphPartition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphPartition* internal_default_instance() {
    return reinterpret_cast<const GraphPartition*>(
               &_GraphPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GraphPartition* other);
  friend void swap(GraphPartition& a, GraphPartition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphPartition* New() const final {
    return CreateMaybeMessage<GraphPartition>(NULL);
  }

  GraphPartition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphPartition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphPartition& from);
  void MergeFrom(const GraphPartition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphPartition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GraphPartition_Input Input;
  typedef GraphPartition_Output Output;
  typedef GraphPartition_Node Node;
  typedef GraphPartition_Edge Edge;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.GraphPartition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Submission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Submission) */ {
 public:
  Submission();
  virtual ~Submission();

  Submission(const Submission& from);

  inline Submission& operator=(const Submission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Submission(Submission&& from) noexcept
    : Submission() {
    *this = ::std::move(from);
  }

  inline Submission& operator=(Submission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Submission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Submission* internal_default_instance() {
    return reinterpret_cast<const Submission*>(
               &_Submission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Submission* other);
  friend void swap(Submission& a, Submission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Submission* New() const final {
    return CreateMaybeMessage<Submission>(NULL);
  }

  Submission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Submission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Submission& from);
  void MergeFrom(const Submission& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Submission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string problem = 1;
  void clear_problem();
  static const int kProblemFieldNumber = 1;
  const ::std::string& problem() const;
  void set_problem(const ::std::string& value);
  #if LANG_CXX11
  void set_problem(::std::string&& value);
  #endif
  void set_problem(const char* value);
  void set_problem(const char* value, size_t size);
  ::std::string* mutable_problem();
  ::std::string* release_problem();
  void set_allocated_problem(::std::string* problem);

  // string instance = 2;
  void clear_instance();
  static const int kInstanceFieldNumber = 2;
  const ::std::string& instance() const;
  void set_instance(const ::std::string& value);
  #if LANG_CXX11
  void set_instance(::std::string&& value);
  #endif
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  ::std::string* mutable_instance();
  ::std::string* release_instance();
  void set_allocated_instance(::std::string* instance);

  // string duration = 13;
  void clear_duration();
  static const int kDurationFieldNumber = 13;
  const ::std::string& duration() const;
  void set_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_duration(::std::string&& value);
  #endif
  void set_duration(const char* value);
  void set_duration(const char* value, size_t size);
  ::std::string* mutable_duration();
  ::std::string* release_duration();
  void set_allocated_duration(::std::string* duration);

  // int32 partnum = 3;
  void clear_partnum();
  static const int kPartnumFieldNumber = 3;
  ::google::protobuf::int32 partnum() const;
  void set_partnum(::google::protobuf::int32 value);

  // int32 obj = 11;
  void clear_obj();
  static const int kObjFieldNumber = 11;
  ::google::protobuf::int32 obj() const;
  void set_obj(::google::protobuf::int32 value);

  // double imbalance = 12;
  void clear_imbalance();
  static const int kImbalanceFieldNumber = 12;
  double imbalance() const;
  void set_imbalance(double value);

  // @@protoc_insertion_point(class_scope:pb.Submission)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr problem_;
  ::google::protobuf::internal::ArenaStringPtr instance_;
  ::google::protobuf::internal::ArenaStringPtr duration_;
  ::google::protobuf::int32 partnum_;
  ::google::protobuf::int32 obj_;
  double imbalance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GraphPartition_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GraphPartition_Input

// repeated .pb.GraphPartition.Node nodes = 1;
inline int GraphPartition_Input::nodes_size() const {
  return nodes_.size();
}
inline void GraphPartition_Input::clear_nodes() {
  nodes_.Clear();
}
inline ::pb::GraphPartition_Node* GraphPartition_Input::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GraphPartition.Input.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Node >*
GraphPartition_Input::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:pb.GraphPartition.Input.nodes)
  return &nodes_;
}
inline const ::pb::GraphPartition_Node& GraphPartition_Input::nodes(int index) const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Input.nodes)
  return nodes_.Get(index);
}
inline ::pb::GraphPartition_Node* GraphPartition_Input::add_nodes() {
  // @@protoc_insertion_point(field_add:pb.GraphPartition.Input.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Node >&
GraphPartition_Input::nodes() const {
  // @@protoc_insertion_point(field_list:pb.GraphPartition.Input.nodes)
  return nodes_;
}

// repeated .pb.GraphPartition.Edge edges = 2;
inline int GraphPartition_Input::edges_size() const {
  return edges_.size();
}
inline void GraphPartition_Input::clear_edges() {
  edges_.Clear();
}
inline ::pb::GraphPartition_Edge* GraphPartition_Input::mutable_edges(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GraphPartition.Input.edges)
  return edges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Edge >*
GraphPartition_Input::mutable_edges() {
  // @@protoc_insertion_point(field_mutable_list:pb.GraphPartition.Input.edges)
  return &edges_;
}
inline const ::pb::GraphPartition_Edge& GraphPartition_Input::edges(int index) const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Input.edges)
  return edges_.Get(index);
}
inline ::pb::GraphPartition_Edge* GraphPartition_Input::add_edges() {
  // @@protoc_insertion_point(field_add:pb.GraphPartition.Input.edges)
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::GraphPartition_Edge >&
GraphPartition_Input::edges() const {
  // @@protoc_insertion_point(field_list:pb.GraphPartition.Input.edges)
  return edges_;
}

// -------------------------------------------------------------------

// GraphPartition_Output

// repeated int32 nodepart = 1;
inline int GraphPartition_Output::nodepart_size() const {
  return nodepart_.size();
}
inline void GraphPartition_Output::clear_nodepart() {
  nodepart_.Clear();
}
inline ::google::protobuf::int32 GraphPartition_Output::nodepart(int index) const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Output.nodepart)
  return nodepart_.Get(index);
}
inline void GraphPartition_Output::set_nodepart(int index, ::google::protobuf::int32 value) {
  nodepart_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.GraphPartition.Output.nodepart)
}
inline void GraphPartition_Output::add_nodepart(::google::protobuf::int32 value) {
  nodepart_.Add(value);
  // @@protoc_insertion_point(field_add:pb.GraphPartition.Output.nodepart)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GraphPartition_Output::nodepart() const {
  // @@protoc_insertion_point(field_list:pb.GraphPartition.Output.nodepart)
  return nodepart_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GraphPartition_Output::mutable_nodepart() {
  // @@protoc_insertion_point(field_mutable_list:pb.GraphPartition.Output.nodepart)
  return &nodepart_;
}

// -------------------------------------------------------------------

// GraphPartition_Node

// int32 wgt = 1;
inline void GraphPartition_Node::clear_wgt() {
  wgt_ = 0;
}
inline ::google::protobuf::int32 GraphPartition_Node::wgt() const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Node.wgt)
  return wgt_;
}
inline void GraphPartition_Node::set_wgt(::google::protobuf::int32 value) {
  
  wgt_ = value;
  // @@protoc_insertion_point(field_set:pb.GraphPartition.Node.wgt)
}

// -------------------------------------------------------------------

// GraphPartition_Edge

// int32 beg = 1;
inline void GraphPartition_Edge::clear_beg() {
  beg_ = 0;
}
inline ::google::protobuf::int32 GraphPartition_Edge::beg() const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Edge.beg)
  return beg_;
}
inline void GraphPartition_Edge::set_beg(::google::protobuf::int32 value) {
  
  beg_ = value;
  // @@protoc_insertion_point(field_set:pb.GraphPartition.Edge.beg)
}

// int32 end = 2;
inline void GraphPartition_Edge::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 GraphPartition_Edge::end() const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Edge.end)
  return end_;
}
inline void GraphPartition_Edge::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:pb.GraphPartition.Edge.end)
}

// int32 wgt = 3;
inline void GraphPartition_Edge::clear_wgt() {
  wgt_ = 0;
}
inline ::google::protobuf::int32 GraphPartition_Edge::wgt() const {
  // @@protoc_insertion_point(field_get:pb.GraphPartition.Edge.wgt)
  return wgt_;
}
inline void GraphPartition_Edge::set_wgt(::google::protobuf::int32 value) {
  
  wgt_ = value;
  // @@protoc_insertion_point(field_set:pb.GraphPartition.Edge.wgt)
}

// -------------------------------------------------------------------

// GraphPartition

// -------------------------------------------------------------------

// Submission

// string problem = 1;
inline void Submission::clear_problem() {
  problem_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::problem() const {
  // @@protoc_insertion_point(field_get:pb.Submission.problem)
  return problem_.GetNoArena();
}
inline void Submission::set_problem(const ::std::string& value) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.problem)
}
#if LANG_CXX11
inline void Submission::set_problem(::std::string&& value) {
  
  problem_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.problem)
}
#endif
inline void Submission::set_problem(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.problem)
}
inline void Submission::set_problem(const char* value, size_t size) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.problem)
}
inline ::std::string* Submission::mutable_problem() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.problem)
  return problem_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_problem() {
  // @@protoc_insertion_point(field_release:pb.Submission.problem)
  
  return problem_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_problem(::std::string* problem) {
  if (problem != NULL) {
    
  } else {
    
  }
  problem_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), problem);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.problem)
}

// string instance = 2;
inline void Submission::clear_instance() {
  instance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::instance() const {
  // @@protoc_insertion_point(field_get:pb.Submission.instance)
  return instance_.GetNoArena();
}
inline void Submission::set_instance(const ::std::string& value) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.instance)
}
#if LANG_CXX11
inline void Submission::set_instance(::std::string&& value) {
  
  instance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.instance)
}
#endif
inline void Submission::set_instance(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.instance)
}
inline void Submission::set_instance(const char* value, size_t size) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.instance)
}
inline ::std::string* Submission::mutable_instance() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.instance)
  return instance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_instance() {
  // @@protoc_insertion_point(field_release:pb.Submission.instance)
  
  return instance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_instance(::std::string* instance) {
  if (instance != NULL) {
    
  } else {
    
  }
  instance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.instance)
}

// int32 partnum = 3;
inline void Submission::clear_partnum() {
  partnum_ = 0;
}
inline ::google::protobuf::int32 Submission::partnum() const {
  // @@protoc_insertion_point(field_get:pb.Submission.partnum)
  return partnum_;
}
inline void Submission::set_partnum(::google::protobuf::int32 value) {
  
  partnum_ = value;
  // @@protoc_insertion_point(field_set:pb.Submission.partnum)
}

// int32 obj = 11;
inline void Submission::clear_obj() {
  obj_ = 0;
}
inline ::google::protobuf::int32 Submission::obj() const {
  // @@protoc_insertion_point(field_get:pb.Submission.obj)
  return obj_;
}
inline void Submission::set_obj(::google::protobuf::int32 value) {
  
  obj_ = value;
  // @@protoc_insertion_point(field_set:pb.Submission.obj)
}

// double imbalance = 12;
inline void Submission::clear_imbalance() {
  imbalance_ = 0;
}
inline double Submission::imbalance() const {
  // @@protoc_insertion_point(field_get:pb.Submission.imbalance)
  return imbalance_;
}
inline void Submission::set_imbalance(double value) {
  
  imbalance_ = value;
  // @@protoc_insertion_point(field_set:pb.Submission.imbalance)
}

// string duration = 13;
inline void Submission::clear_duration() {
  duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::duration() const {
  // @@protoc_insertion_point(field_get:pb.Submission.duration)
  return duration_.GetNoArena();
}
inline void Submission::set_duration(const ::std::string& value) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.duration)
}
#if LANG_CXX11
inline void Submission::set_duration(::std::string&& value) {
  
  duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.duration)
}
#endif
inline void Submission::set_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.duration)
}
inline void Submission::set_duration(const char* value, size_t size) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.duration)
}
inline ::std::string* Submission::mutable_duration() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.duration)
  return duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_duration() {
  // @@protoc_insertion_point(field_release:pb.Submission.duration)
  
  return duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_duration(::std::string* duration) {
  if (duration != NULL) {
    
  } else {
    
  }
  duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duration);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.duration)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_GraphPartition_2eproto
